(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{167:function(t,e,a){"use strict";a.r(e);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"react生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" React生命周期")]),t._v(" "),a("h3",{attrs:{id:"react16当前生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react16当前生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" react16当前生命周期")]),t._v(" "),a("h5",{attrs:{id:"_1、componentdidmount-组件挂载完成之后触发的生命周期-相当于vue的mounted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、componentdidmount-组件挂载完成之后触发的生命周期-相当于vue的mounted","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、componentDidMount() // 组件挂载完成之后触发的生命周期 相当于vue的mounted")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentDidMount(){\n    setInterval(()=>{\n        // 修改state的唯一方法\n        // @param 要修改的数据\n        // @param 修改完成之后的回调函数\n        this.setState({\n            index:this.state.index++\n        },()=>{\n            consloe.log(this.state.index)\n        })\n    },1000)\n}\n\n")])])]),a("h5",{attrs:{id:"_2、componentwillmount-组件挂载之前-相当于vue的beforemount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、componentwillmount-组件挂载之前-相当于vue的beforemount","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、componentWillMount()  // 组件挂载之前 相当于vue的beforeMount")]),t._v(" "),a("h5",{attrs:{id:"_3、componentwillreceiveprops-nextprops-组件将要接收新的props-vue没有"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、componentwillreceiveprops-nextprops-组件将要接收新的props-vue没有","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、componentWillReceiveProps(nextProps)  // 组件将要接收新的props vue没有")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 和props相关的唯一一个生命周期\n// 执行完成之后，this.props指向新的props\ncomponentWillReceiveProps(nextProps){\n    // 旧的props   this.props\n    // 新的props   nextProps\n    \n}\n\n\n")])])]),a("h5",{attrs:{id:"_4、shouldcomponentupdate-nextprops-nextstate-通过返回值判断组件是否需要更新-用于react优化，vue没有-true更新，false不更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、shouldcomponentupdate-nextprops-nextstate-通过返回值判断组件是否需要更新-用于react优化，vue没有-true更新，false不更新","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、shouldComponentUpdate(nextProps,nextState)  // 通过返回值判断组件是否需要更新,用于react优化，vue没有 true更新，false不更新")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("shouldComponentUpdate(nextProps,nextState){\n    // 旧的props   this.props\n    // 新的props   nextProps\n    // 旧的State   this.state\n    // 新的state   nextState\n    // 返回值是Boolean  默认true\n}\n\n\n")])])]),a("h5",{attrs:{id:"_5、componentwillupdate-组件将要更新-相当于vue的beforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、componentwillupdate-组件将要更新-相当于vue的beforeupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" 5、componentWillUpdate // 组件将要更新 相当于vue的beforeUpdate")]),t._v(" "),a("h5",{attrs:{id:"_6、componentdidupdate-组件更新完成-相当于vue的updated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、componentdidupdate-组件更新完成-相当于vue的updated","aria-hidden":"true"}},[t._v("#")]),t._v(" 6、componentDidUpdate // 组件更新完成 相当于vue的updated")]),t._v(" "),a("h5",{attrs:{id:"_7、componentwillunmount-组件将要卸载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、componentwillunmount-组件将要卸载","aria-hidden":"true"}},[t._v("#")]),t._v(" 7、componentWillUnmount() // 组件将要卸载")]),t._v(" "),a("h5",{attrs:{id:"_8、unmountcomponentatnode-卸载组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、unmountcomponentatnode-卸载组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 8、unmountComponentAtNode() // 卸载组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ReactDom.unmountComponentAtNode(document.getElementById('root'))\n")])])]),a("h5",{attrs:{id:"_9、分为三个阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、分为三个阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" 9、分为三个阶段")]),t._v(" "),a("p",[a("strong",[t._v("1. 实例化阶段")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("首次使用一个组件类时会有getDefaultProps\n对于组件类的所有后续应用没有getDefaultProps\n1、getDefaultProps\n2、getInitialState\n3、componentWillMount\n4、render\n5、componentDidMount\n")])])]),a("p",[a("strong",[t._v("2. 更新阶段(存在期)")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. componentWillReceiveProps \n2. shouldComponentUpdate \n3. componentWillUpdate \n4. render \n5. componentDidUpdate\n")])])]),a("p",[a("strong",[t._v("3. 销毁&清理期")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentWillUnmount\n")])])]),a("p",[t._v("react官方打算在未来提出一种实现异步渲染的方法以提高性能，主要的特点就是在渲染完成之前可以被中断，中断之后不会继续执行生命周期，而是重头开始执行生命周期。")]),t._v(" "),a("h5",{attrs:{id:"从v17开始删除以下三个生命周期钩子："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从v17开始删除以下三个生命周期钩子：","aria-hidden":"true"}},[t._v("#")]),t._v(" 从v17开始删除以下三个生命周期钩子：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate\n")])])]),a("h3",{attrs:{id:"新增两个新生命周期钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新增两个新生命周期钩子","aria-hidden":"true"}},[t._v("#")]),t._v(" 新增两个新生命周期钩子")]),t._v(" "),a("h4",{attrs:{id:"static-getderivedstatefromprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromprops","aria-hidden":"true"}},[t._v("#")]),t._v(" static getDerivedStateFromProps")]),t._v(" "),a("p",[t._v("用法：")]),t._v(" "),a("pre",[a("code",[t._v("触发时间：\n实例创建之后\n每次获取到新的props或者新的state（即setState）之后\n")])]),t._v(" "),a("p",[t._v("参数")]),t._v(" "),a("pre",[a("code",[t._v("nextProps\nnextState\n")])]),t._v(" "),a("p",[t._v("返回值")]),t._v(" "),a("pre",[a("code",[t._v("如果返回一个Object，则相当于进行一次setState操作（注意，这里返回对象虽然改变了state，但不会再次触发此函数）\n如果为null，则不更新state\n如果无返回值（即默认return undefined），报错\n如果返回一个基本类型值（如return 666;），则与返回null无区别\n")])]),t._v(" "),a("p",[t._v("这里需要注意的是：")]),t._v(" "),a("pre",[a("code",[t._v("1.getDerivedStateFromProps是一个静态方法，this为undefined，不指向实例，所以也拿不到实例的属性和方法。至于为什么要将此方法设计为静态方法，官方文档解释：以后的组件将进行异步渲染，防止实例属性的被不安全访问，编写出异步兼容的代码\n\n2.此方法不提供一个prevProps的参数，官方解释为，首次执行此方法，prevProps是null，那么每次调用此方法都要判断一次，很耗性能。其次，如果大家以后都习惯没有prevProps的日子，那么react就不保存prevProps的引用了，节省内存，提高性能（心里一万匹***奔腾而过）\n\n3.如果要访问prevProps，只能将一些props的属性记录到state里面去了\n\n4.不能同上述提到即将要被删除掉的三个生命周期钩子同时使用\n")])]),t._v(" "),a("h4",{attrs:{id:"getsnapshotbeforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getsnapshotbeforeupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" getSnapshotBeforeUpdate")]),t._v(" "),a("p",[t._v("用法:")]),t._v(" "),a("pre",[a("code",[t._v("1.触发时间：update发生的时候，在render之后，在组件dom渲染之前\n2.参数：prevProps, prevState（prevState为上一次更新中getDerivedStateFromProps方法执行后state的值）\n3.返回值可以为任意值，且返回值将作为componentDidUpdate的第三个参数\n")])]),t._v(" "),a("p",[t._v("这里需要注意的是：")]),t._v(" "),a("pre",[a("code",[t._v("1.与componentDidUpdate成对使用，否则会报错\n2.不能同上述提到即将要被删除掉的三个生命周期钩子同时使用\n")])]),t._v(" "),a("h4",{attrs:{id:"为什么要删除三个生命周期钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要删除三个生命周期钩子","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么要删除三个生命周期钩子")]),t._v(" "),a("p",[t._v("其实官方解释是，很多react用户（包括我）都存在错误的使用这三个生命周期钩子的行为，导致以后异步渲染时，会导致极大的性能损耗，所以强制将这三个钩子删除掉（v17版本之后，现在还是可以使用的）。那接下来看看在这三个生命周期到底存在什么错误的用法：")]),t._v(" "),a("h4",{attrs:{id:"componentwillmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillmount","aria-hidden":"true"}},[t._v("#")]),t._v(" componentWillMount")]),t._v(" "),a("p",[t._v("错误做法：")]),t._v(" "),a("ul",[a("li",[t._v("天真地认为在这里请求异步数据，首屏渲染就会有数据了")]),t._v(" "),a("li",[t._v("在此添加事件监听方法")]),t._v(" "),a("li",[t._v("在此初始化state（根据props进行setState）")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("在此发起异步数据请求之后，会立刻调用render方法，那么首屏渲染还是没有数据")]),t._v(" "),a("li",[t._v("服务器渲染，不会调用componentWillUnmount方法，那么在此钩子里面添加的事件监听方法就无法被浏览器移除，导致内存泄露；同时，在此钩子请求异步数据，也无法首屏渲染数据（原因同上一点），返回到前端还是空白页面。")]),t._v(" "),a("li",[t._v("上面提到多，渲染可被打断，如果被打断，那么就可能会多次调用此钩子，导致多次请求数据，消耗性能")])]),t._v(" "),a("p",[t._v("优化")]),t._v(" "),a("ul",[a("li",[t._v("在constructor里面进行state的初始化")]),t._v(" "),a("li",[t._v("在componentDidMount里面请求异步数据和添加事件监听方法（因为此时能够确保componentWillUnmount钩子一定会执行，就可在这个地方进行销毁事件监听器，回收内存）")]),t._v(" "),a("li",[t._v("解决服务端渲染的问题，可以查阅一下react的同构直出的方法")])]),t._v(" "),a("h4",{attrs:{id:"componentwillreceiveprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops","aria-hidden":"true"}},[t._v("#")]),t._v(" componentWillReceiveProps")]),t._v(" "),a("p",[t._v("错误做法：")]),t._v(" "),a("ul",[a("li",[t._v("根据前后props数据的对比更新state")]),t._v(" "),a("li",[t._v("根据前后props数据的对比请求异步数据")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("更新state方式不优雅")]),t._v(" "),a("li",[t._v("职能不专，同时进行setState和获取异步数据等会触发新一轮组件更新的操作")]),t._v(" "),a("li",[t._v("渲染可被中断，会多次请求数据")])]),t._v(" "),a("p",[t._v("优化：")]),t._v(" "),a("ul",[a("li",[t._v("使用getDerivedStateFromProps返回值来更新state")]),t._v(" "),a("li",[t._v("在componentDidUpdate获取数据")])]),t._v(" "),a("h4",{attrs:{id:"componentwillupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" componentWillUpdate")]),t._v(" "),a("p",[t._v("错误做法：")]),t._v(" "),a("ul",[a("li",[t._v("根据新的state发起异步数据请求")]),t._v(" "),a("li",[t._v("在此进行外部函数调用（如nextProps.someMethod()）")]),t._v(" "),a("li",[t._v("记录更新前一些节点的属性（这个做法没错，只是现在有更好的方式）")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("异步数据和外部函数调用请求的缺点同前面两个钩子的一样")]),t._v(" "),a("li",[t._v("记录的信息如果放在state中，需要额外的判断（会进行两次更新）")])]),t._v(" "),a("p",[t._v("优化：")]),t._v(" "),a("ul",[a("li",[t._v("在componentDidUpdate 在此处数据请求和外部函数调用")]),t._v(" "),a("li",[t._v("在getSnapshotBeforeUpdate记录当前节点信息，记录的信息通过返回值传递给componentDidUpdate作为第三个参数（省内存，仅一次更新）")])])])}],!1,null,null,null);e.default=r.exports}}]);